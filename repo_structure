├── app
    ├── (auth)
    │   ├── actions.ts
    │   ├── api
    │   │   └── auth
    │   │   │   └── [...nextauth]
    │   │   │       └── route.ts
    │   ├── auth.config.ts
    │   └── auth.ts
    ├── (chat)
    │   ├── actions.ts
    │   └── api
    │   │   ├── chat
    │   │       └── route.ts
    │   │   ├── document
    │   │       └── route.ts
    │   │   ├── files
    │   │       └── upload
    │   │       │   └── route.ts
    │   │   ├── history
    │   │       └── route.ts
    │   │   ├── suggestions
    │   │       └── route.ts
    │   │   └── vote
    │   │       └── route.ts
    └── api
    │   └── chat
    │       └── route.ts
├── components
    └── use-scroll-to-bottom.ts
├── drizzle.config.ts
├── lib
    ├── ai
    │   ├── custom-middleware.ts
    │   ├── index.ts
    │   ├── models.ts
    │   └── prompts.ts
    ├── db
    │   ├── migrate.ts
    │   ├── queries.ts
    │   └── schema.ts
    ├── editor
    │   └── config.ts
    └── utils.ts
├── middleware.ts
├── next-env.d.ts
├── next.config.ts
├── tailwind.config.ts
└── types
    └── chat.ts


/app/(auth)/actions.ts:
--------------------------------------------------------------------------------
 1 | 'use server';
 2 | 
 3 | import { z } from 'zod';
 4 | 
 5 | import { createUser, getUser } from '@/lib/db/queries';
 6 | 
 7 | import { signIn } from './auth';
 8 | 
 9 | const authFormSchema = z.object({
10 |   email: z.string().email(),
11 |   password: z.string().min(6),
12 | });
13 | 
14 | export interface LoginActionState {
15 |   status: 'idle' | 'in_progress' | 'success' | 'failed' | 'invalid_data';
16 | }
17 | 
18 | export const login = async (
19 |   _: LoginActionState,
20 |   formData: FormData,
21 | ): Promise<LoginActionState> => {
22 |   try {
23 |     const validatedData = authFormSchema.parse({
24 |       email: formData.get('email'),
25 |       password: formData.get('password'),
26 |     });
27 | 
28 |     await signIn('credentials', {
29 |       email: validatedData.email,
30 |       password: validatedData.password,
31 |       redirect: false,
32 |     });
33 | 
34 |     return { status: 'success' };
35 |   } catch (error) {
36 |     if (error instanceof z.ZodError) {
37 |       return { status: 'invalid_data' };
38 |     }
39 | 
40 |     return { status: 'failed' };
41 |   }
42 | };
43 | 
44 | export interface RegisterActionState {
45 |   status:
46 |     | 'idle'
47 |     | 'in_progress'
48 |     | 'success'
49 |     | 'failed'
50 |     | 'user_exists'
51 |     | 'invalid_data';
52 | }
53 | 
54 | export const register = async (
55 |   _: RegisterActionState,
56 |   formData: FormData,
57 | ): Promise<RegisterActionState> => {
58 |   try {
59 |     const validatedData = authFormSchema.parse({
60 |       email: formData.get('email'),
61 |       password: formData.get('password'),
62 |     });
63 | 
64 |     const [user] = await getUser(validatedData.email);
65 | 
66 |     if (user) {
67 |       return { status: 'user_exists' } as RegisterActionState;
68 |     }
69 |     await createUser(validatedData.email, validatedData.password);
70 |     await signIn('credentials', {
71 |       email: validatedData.email,
72 |       password: validatedData.password,
73 |       redirect: false,
74 |     });
75 | 
76 |     return { status: 'success' };
77 |   } catch (error) {
78 |     if (error instanceof z.ZodError) {
79 |       return { status: 'invalid_data' };
80 |     }
81 | 
82 |     return { status: 'failed' };
83 |   }
84 | };
85 | 


--------------------------------------------------------------------------------
/app/(auth)/api/auth/[...nextauth]/route.ts:
--------------------------------------------------------------------------------
1 | export { GET, POST } from '@/app/(auth)/auth';
2 | 


--------------------------------------------------------------------------------
/app/(auth)/auth.config.ts:
--------------------------------------------------------------------------------
 1 | import type { NextAuthConfig } from 'next-auth';
 2 | 
 3 | export const authConfig = {
 4 |   pages: {
 5 |     signIn: '/login',
 6 |     newUser: '/',
 7 |   },
 8 |   providers: [
 9 |     // added later in auth.ts since it requires bcrypt which is only compatible with Node.js
10 |     // while this file is also used in non-Node.js environments
11 |   ],
12 |   callbacks: {
13 |     authorized({ auth, request: { nextUrl } }) {
14 |       const isLoggedIn = !!auth?.user;
15 |       const isOnChat = nextUrl.pathname.startsWith('/');
16 |       const isOnRegister = nextUrl.pathname.startsWith('/register');
17 |       const isOnLogin = nextUrl.pathname.startsWith('/login');
18 | 
19 |       if (isLoggedIn && (isOnLogin || isOnRegister)) {
20 |         return Response.redirect(new URL('/', nextUrl as unknown as URL));
21 |       }
22 | 
23 |       if (isOnRegister || isOnLogin) {
24 |         return true; // Always allow access to register and login pages
25 |       }
26 | 
27 |       if (isOnChat) {
28 |         if (isLoggedIn) return true;
29 |         return false; // Redirect unauthenticated users to login page
30 |       }
31 | 
32 |       if (isLoggedIn) {
33 |         return Response.redirect(new URL('/', nextUrl as unknown as URL));
34 |       }
35 | 
36 |       return true;
37 |     },
38 |   },
39 | } satisfies NextAuthConfig;
40 | 


--------------------------------------------------------------------------------
/app/(auth)/auth.ts:
--------------------------------------------------------------------------------
 1 | import { compare } from 'bcrypt-ts';
 2 | import NextAuth, { type User, type Session } from 'next-auth';
 3 | import Credentials from 'next-auth/providers/credentials';
 4 | 
 5 | import { getUser } from '@/lib/db/queries';
 6 | 
 7 | import { authConfig } from './auth.config';
 8 | 
 9 | interface ExtendedSession extends Session {
10 |   user: User;
11 | }
12 | 
13 | export const {
14 |   handlers: { GET, POST },
15 |   auth,
16 |   signIn,
17 |   signOut,
18 | } = NextAuth({
19 |   ...authConfig,
20 |   providers: [
21 |     Credentials({
22 |       credentials: {},
23 |       async authorize({ email, password }: any) {
24 |         const users = await getUser(email);
25 |         if (users.length === 0) return null;
26 |         // biome-ignore lint: Forbidden non-null assertion.
27 |         const passwordsMatch = await compare(password, users[0].password!);
28 |         if (!passwordsMatch) return null;
29 |         return users[0] as any;
30 |       },
31 |     }),
32 |   ],
33 |   callbacks: {
34 |     async jwt({ token, user }) {
35 |       if (user) {
36 |         token.id = user.id;
37 |       }
38 | 
39 |       return token;
40 |     },
41 |     async session({
42 |       session,
43 |       token,
44 |     }: {
45 |       session: ExtendedSession;
46 |       token: any;
47 |     }) {
48 |       if (session.user) {
49 |         session.user.id = token.id as string;
50 |       }
51 | 
52 |       return session;
53 |     },
54 |   },
55 | });
56 | 


--------------------------------------------------------------------------------
/app/(chat)/actions.ts:
--------------------------------------------------------------------------------
 1 | 'use server';
 2 | 
 3 | import { type CoreUserMessage } from 'ai';
 4 | import { Anthropic } from '@anthropic-ai/sdk';
 5 | import { cookies } from 'next/headers';
 6 | 
 7 | if (!process.env.ANTHROPIC_API_KEY) {
 8 |   throw new Error('Missing ANTHROPIC_API_KEY environment variable');
 9 | }
10 | 
11 | const anthropic = new Anthropic({
12 |   apiKey: process.env.ANTHROPIC_API_KEY,
13 | });
14 | 
15 | export async function saveModelId(model: string) {
16 |   const cookieStore = await cookies();
17 |   cookieStore.set('model-id', model);
18 | }
19 | 
20 | export async function generateTitleFromUserMessage({
21 |   message,
22 | }: {
23 |   message: CoreUserMessage;
24 | }) {
25 |   const response = await anthropic.messages.create({
26 |     model: 'claude-3-5-sonnet-20241022',
27 |     system: `
28 |     - you will generate a short title based on the first message a user begins a conversation with
29 |     - ensure it is not more than 80 characters long
30 |     - the title should be a summary of the user's message
31 |     - do not use quotes or colons`,
32 |     messages: [{ role: 'user', content: JSON.stringify(message) }],
33 |     max_tokens: 100,
34 |   });
35 | 
36 |   return response.content[0].text;
37 | }
38 | 


--------------------------------------------------------------------------------
/app/(chat)/api/chat/route.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   type Message,
 3 |   convertToCoreMessages,
 4 | } from 'ai';
 5 | import { z } from 'zod';
 6 | import { Attachment } from '@/types/chat';
 7 | 
 8 | import { auth } from '@/app/(auth)/auth';
 9 | import { customModel } from '@/lib/ai';
10 | import { models } from '@/lib/ai/models';
11 | import { systemPrompt } from '@/lib/ai/prompts';
12 | import {
13 |   deleteChatById,
14 |   getChatById,
15 |   saveChat,
16 |   saveMessages,
17 | } from '@/lib/db/queries';
18 | import {
19 |   generateUUID,
20 |   getMostRecentUserMessage,
21 | } from '@/lib/utils';
22 | 
23 | import { generateTitleFromUserMessage } from '../../actions';
24 | 
25 | export const maxDuration = 60;
26 | 
27 | export async function POST(request: Request) {
28 |   const { id, messages, modelId } = await request.json();
29 |   
30 |   const session = await auth();
31 |   if (!session?.user?.id) {
32 |     return new Response('Unauthorized', { status: 401 });
33 |   }
34 | 
35 |   const model = models.find((model) => model.id === modelId);
36 |   if (!model) {
37 |     return new Response('Model not found', { status: 404 });
38 |   }
39 | 
40 |   // Handle attachments if present
41 |   const lastMessage = messages[messages.length - 1];
42 |   if (lastMessage.experimental_attachments?.length) {
43 |     const attachments = lastMessage.experimental_attachments.map(attachment => ({
44 |       type: "base64",
45 |       source: attachment.base64,
46 |       name: attachment.name
47 |     }));
48 | 
49 |     const response = await customModel(modelId).invoke({
50 |       messages,
51 |       options: { 
52 |         system: systemPrompt,
53 |         attachments 
54 |       }
55 |     });
56 | 
57 |     return new Response(response, {
58 |       headers: {
59 |         'Content-Type': 'text/event-stream',
60 |         'Cache-Control': 'no-cache, no-transform',
61 |         'Connection': 'keep-alive',
62 |       },
63 |     });
64 |   }
65 | 
66 |   const response = await customModel(model.apiIdentifier).invoke({
67 |     messages,
68 |     options: { system: systemPrompt }
69 |   });
70 | 
71 |   return new Response(response, {
72 |     headers: {
73 |       'Content-Type': 'text/event-stream',
74 |       'Cache-Control': 'no-cache, no-transform',
75 |       'Connection': 'keep-alive',
76 |     },
77 |   });
78 | }
79 | 
80 | export async function DELETE(request: Request) {
81 |   const { searchParams } = new URL(request.url);
82 |   const id = searchParams.get('id');
83 | 
84 |   const session = await auth();
85 | 
86 |   if (!session?.user?.id) {
87 |     return new Response('Unauthorized', { status: 401 });
88 |   }
89 | 
90 |   if (!id) {
91 |     return new Response('Missing chat ID', { status: 400 });
92 |   }
93 | 
94 |   await deleteChatById({ id });
95 | 
96 |   return new Response('OK');
97 | }


--------------------------------------------------------------------------------
/app/(chat)/api/document/route.ts:
--------------------------------------------------------------------------------
 1 | import { auth } from '@/app/(auth)/auth';
 2 | import {
 3 |   deleteDocumentsByIdAfterTimestamp,
 4 |   getDocumentsById,
 5 |   saveDocument,
 6 | } from '@/lib/db/queries';
 7 | 
 8 | export async function GET(request: Request) {
 9 |   const { searchParams } = new URL(request.url);
10 |   const id = searchParams.get('id');
11 | 
12 |   if (!id) {
13 |     return new Response('Missing id', { status: 400 });
14 |   }
15 | 
16 |   const session = await auth();
17 | 
18 |   if (!session || !session.user) {
19 |     return new Response('Unauthorized', { status: 401 });
20 |   }
21 | 
22 |   const documents = await getDocumentsById({ id });
23 | 
24 |   const [document] = documents;
25 | 
26 |   if (!document) {
27 |     return new Response('Not Found', { status: 404 });
28 |   }
29 | 
30 |   if (document.userId !== session.user.id) {
31 |     return new Response('Unauthorized', { status: 401 });
32 |   }
33 | 
34 |   return Response.json(documents, { status: 200 });
35 | }
36 | 
37 | export async function POST(request: Request) {
38 |   const { searchParams } = new URL(request.url);
39 |   const id = searchParams.get('id');
40 | 
41 |   if (!id) {
42 |     return new Response('Missing id', { status: 400 });
43 |   }
44 | 
45 |   const session = await auth();
46 | 
47 |   if (!session) {
48 |     return new Response('Unauthorized', { status: 401 });
49 |   }
50 | 
51 |   const { content, title }: { content: string; title: string } =
52 |     await request.json();
53 | 
54 |   if (session.user?.id) {
55 |     const document = await saveDocument({
56 |       id,
57 |       content,
58 |       title,
59 |       userId: session.user.id,
60 |     });
61 | 
62 |     return Response.json(document, { status: 200 });
63 |   }
64 |   return new Response('Unauthorized', { status: 401 });
65 | }
66 | 
67 | export async function PATCH(request: Request) {
68 |   const { searchParams } = new URL(request.url);
69 |   const id = searchParams.get('id');
70 | 
71 |   const { timestamp }: { timestamp: string } = await request.json();
72 | 
73 |   if (!id) {
74 |     return new Response('Missing id', { status: 400 });
75 |   }
76 | 
77 |   const session = await auth();
78 | 
79 |   if (!session || !session.user) {
80 |     return new Response('Unauthorized', { status: 401 });
81 |   }
82 | 
83 |   const documents = await getDocumentsById({ id });
84 | 
85 |   const [document] = documents;
86 | 
87 |   if (document.userId !== session.user.id) {
88 |     return new Response('Unauthorized', { status: 401 });
89 |   }
90 | 
91 |   await deleteDocumentsByIdAfterTimestamp({
92 |     id,
93 |     timestamp: new Date(timestamp),
94 |   });
95 | 
96 |   return new Response('Deleted', { status: 200 });
97 | }
98 | 


--------------------------------------------------------------------------------
/app/(chat)/api/files/upload/route.ts:
--------------------------------------------------------------------------------
 1 | import { put } from '@vercel/blob';
 2 | import { NextResponse } from 'next/server';
 3 | import { z } from 'zod';
 4 | 
 5 | import { auth } from '@/app/(auth)/auth';
 6 | 
 7 | // Use Blob instead of File since File is not available in Node.js environment
 8 | const FileSchema = z.object({
 9 |   file: z
10 |     .instanceof(Blob)
11 |     .refine((file) => file.size <= 10 * 1024 * 1024, {
12 |       message: 'File size should be less than 10MB',
13 |     })
14 |     .refine((file) => file.type === 'application/pdf', {
15 |       message: 'Only PDF files are allowed',
16 |     }),
17 | });
18 | 
19 | export async function POST(request: Request) {
20 |   const session = await auth();
21 | 
22 |   if (!session) {
23 |     return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
24 |   }
25 | 
26 |   if (request.body === null) {
27 |     return new Response('Request body is empty', { status: 400 });
28 |   }
29 | 
30 |   try {
31 |     const formData = await request.formData();
32 |     const file = formData.get('file') as Blob;
33 | 
34 |     if (!file) {
35 |       return NextResponse.json({ error: 'No file uploaded' }, { status: 400 });
36 |     }
37 | 
38 |     const validatedFile = FileSchema.safeParse({ file });
39 | 
40 |     if (!validatedFile.success) {
41 |       const errorMessage = validatedFile.error.errors
42 |         .map((error) => error.message)
43 |         .join(', ');
44 | 
45 |       return NextResponse.json({ error: errorMessage }, { status: 400 });
46 |     }
47 | 
48 |     // Get filename from formData since Blob doesn't have name property
49 |     const filename = (formData.get('file') as File).name;
50 |     const fileBuffer = await file.arrayBuffer();
51 | 
52 |     const buffer = await file.arrayBuffer();
53 |     const base64Content = Buffer.from(buffer).toString('base64');
54 | 
55 |     return NextResponse.json({
56 |       name: file.name,
57 |       type: file.type,
58 |       base64: base64Content
59 |     });
60 |   } catch (error) {
61 |     return NextResponse.json(
62 |       { error: 'Failed to process request' },
63 |       { status: 500 },
64 |     );
65 |   }
66 | }
67 | 


--------------------------------------------------------------------------------
/app/(chat)/api/history/route.ts:
--------------------------------------------------------------------------------
 1 | import { auth } from '@/app/(auth)/auth';
 2 | import { getChatsByUserId } from '@/lib/db/queries';
 3 | 
 4 | export async function GET() {
 5 |   const session = await auth();
 6 | 
 7 |   if (!session || !session.user) {
 8 |     return Response.json('Unauthorized!', { status: 401 });
 9 |   }
10 | 
11 |   // biome-ignore lint: Forbidden non-null assertion.
12 |   const chats = await getChatsByUserId({ id: session.user.id! });
13 |   return Response.json(chats);
14 | }
15 | 


--------------------------------------------------------------------------------
/app/(chat)/api/suggestions/route.ts:
--------------------------------------------------------------------------------
 1 | import { auth } from '@/app/(auth)/auth';
 2 | import { getSuggestionsByDocumentId } from '@/lib/db/queries';
 3 | 
 4 | export async function GET(request: Request) {
 5 |   const { searchParams } = new URL(request.url);
 6 |   const documentId = searchParams.get('documentId');
 7 | 
 8 |   if (!documentId) {
 9 |     return new Response('Not Found', { status: 404 });
10 |   }
11 | 
12 |   const session = await auth();
13 | 
14 |   if (!session || !session.user) {
15 |     return new Response('Unauthorized', { status: 401 });
16 |   }
17 | 
18 |   const suggestions = await getSuggestionsByDocumentId({
19 |     documentId,
20 |   });
21 | 
22 |   const [suggestion] = suggestions;
23 | 
24 |   if (!suggestion) {
25 |     return Response.json([], { status: 200 });
26 |   }
27 | 
28 |   if (suggestion.userId !== session.user.id) {
29 |     return new Response('Unauthorized', { status: 401 });
30 |   }
31 | 
32 |   return Response.json(suggestions, { status: 200 });
33 | }
34 | 


--------------------------------------------------------------------------------
/app/(chat)/api/vote/route.ts:
--------------------------------------------------------------------------------
 1 | import { auth } from '@/app/(auth)/auth';
 2 | import { getVotesByChatId, voteMessage } from '@/lib/db/queries';
 3 | 
 4 | export async function GET(request: Request) {
 5 |   const { searchParams } = new URL(request.url);
 6 |   const chatId = searchParams.get('chatId');
 7 | 
 8 |   if (!chatId) {
 9 |     return new Response('chatId is required', { status: 400 });
10 |   }
11 | 
12 |   const session = await auth();
13 | 
14 |   if (!session || !session.user || !session.user.email) {
15 |     return new Response('Unauthorized', { status: 401 });
16 |   }
17 | 
18 |   const votes = await getVotesByChatId({ id: chatId });
19 | 
20 |   return Response.json(votes, { status: 200 });
21 | }
22 | 
23 | export async function PATCH(request: Request) {
24 |   const {
25 |     chatId,
26 |     messageId,
27 |     type,
28 |   }: { chatId: string; messageId: string; type: 'up' | 'down' } =
29 |     await request.json();
30 | 
31 |   if (!chatId || !messageId || !type) {
32 |     return new Response('messageId and type are required', { status: 400 });
33 |   }
34 | 
35 |   const session = await auth();
36 | 
37 |   if (!session || !session.user || !session.user.email) {
38 |     return new Response('Unauthorized', { status: 401 });
39 |   }
40 | 
41 |   await voteMessage({
42 |     chatId,
43 |     messageId,
44 |     type: type,
45 |   });
46 | 
47 |   return new Response('Message voted', { status: 200 });
48 | }
49 | 


--------------------------------------------------------------------------------
/app/api/chat/route.ts:
--------------------------------------------------------------------------------
 1 | import { Message } from '@/types/chat';
 2 | import { Anthropic } from '@anthropic-ai/sdk';
 3 | 
 4 | const anthropic = new Anthropic({
 5 |   apiKey: process.env.ANTHROPIC_API_KEY!,
 6 | });
 7 | 
 8 | export async function POST(request: Request) {
 9 |   const { messages, modelId } = await request.json();
10 |   
11 |   const formattedMessages = messages.map((message: Message) => {
12 |     if (!message.experimental_attachments?.length) {
13 |       return {
14 |         role: message.role,
15 |         content: message.content
16 |       };
17 |     }
18 | 
19 |     return {
20 |       role: message.role,
21 |       content: [
22 |         ...message.experimental_attachments.map(attachment => ({
23 |           type: 'document',
24 |           source: {
25 |             type: 'base64',
26 |             media_type: 'application/pdf',
27 |             data: attachment.base64
28 |           }
29 |         })),
30 |         {
31 |           type: 'text',
32 |           text: message.content
33 |         }
34 |       ]
35 |     };
36 |   });
37 | 
38 |   const response = await anthropic.messages.create({
39 |     model: "claude-3-sonnet-20240229",
40 |     max_tokens: 4096,
41 |     messages: formattedMessages
42 |   });
43 | 
44 |   return new Response(response.content[0].text, {
45 |     headers: {
46 |       'Content-Type': 'text/plain',
47 |     }
48 |   });
49 | }
50 | 


--------------------------------------------------------------------------------
/components/use-scroll-to-bottom.ts:
--------------------------------------------------------------------------------
 1 | import { useEffect, useRef, type RefObject } from 'react';
 2 | 
 3 | export function useScrollToBottom<T extends HTMLElement>(): [
 4 |   RefObject<T>,
 5 |   RefObject<T>,
 6 | ] {
 7 |   const containerRef = useRef<T>(null);
 8 |   const endRef = useRef<T>(null);
 9 | 
10 |   useEffect(() => {
11 |     const container = containerRef.current;
12 |     const end = endRef.current;
13 | 
14 |     if (container && end) {
15 |       const observer = new MutationObserver(() => {
16 |         end.scrollIntoView({ behavior: 'instant', block: 'end' });
17 |       });
18 | 
19 |       observer.observe(container, {
20 |         childList: true,
21 |         subtree: true,
22 |         attributes: true,
23 |         characterData: true,
24 |       });
25 | 
26 |       return () => observer.disconnect();
27 |     }
28 |   }, []);
29 | 
30 |   return [containerRef, endRef];
31 | }
32 | 


--------------------------------------------------------------------------------
/drizzle.config.ts:
--------------------------------------------------------------------------------
 1 | import { config } from 'dotenv';
 2 | import { defineConfig } from 'drizzle-kit';
 3 | 
 4 | config({
 5 |   path: '.env.local',
 6 | });
 7 | 
 8 | export default defineConfig({
 9 |   schema: './lib/db/schema.ts',
10 |   out: './lib/db/migrations',
11 |   dialect: 'postgresql',
12 |   dbCredentials: {
13 |     // biome-ignore lint: Forbidden non-null assertion.
14 |     url: process.env.POSTGRES_URL!,
15 |   },
16 | });
17 | 


--------------------------------------------------------------------------------
/lib/ai/custom-middleware.ts:
--------------------------------------------------------------------------------
1 | import type { Experimental_LanguageModelV1Middleware } from 'ai';
2 | 
3 | export const customMiddleware: Experimental_LanguageModelV1Middleware = {};
4 | 


--------------------------------------------------------------------------------
/lib/ai/index.ts:
--------------------------------------------------------------------------------
  1 | import { type Message } from 'ai';
  2 | import { Anthropic } from '@anthropic-ai/sdk';
  3 | 
  4 | if (!process.env.ANTHROPIC_API_KEY) {
  5 |   throw new Error('Missing ANTHROPIC_API_KEY environment variable');
  6 | }
  7 | 
  8 | const anthropic = new Anthropic({
  9 |   apiKey: process.env.ANTHROPIC_API_KEY || '',
 10 | });
 11 | 
 12 | // Helper function to inspect SSE data
 13 | function validateChunkData(data: unknown): boolean {
 14 |   if (!data || typeof data !== 'object') return false;
 15 |   
 16 |   // Check required fields exist and have correct types
 17 |   const fields = {
 18 |     id: 'string',
 19 |     role: 'string',
 20 |     content: 'string',
 21 |     createdAt: 'string'
 22 |   };
 23 |   
 24 |   return Object.entries(fields).every(([field, type]) => {
 25 |     const value = (data as any)[field];
 26 |     return value !== undefined && typeof value === type;
 27 |   });
 28 | }
 29 | 
 30 | interface AIStreamChunk {
 31 |   id: string;
 32 |   role: 'assistant';
 33 |   content: string;
 34 |   createdAt: string;
 35 | }
 36 | 
 37 | function createChunk(messageId: string, content: string): AIStreamChunk {
 38 |   return {
 39 |     id: messageId,
 40 |     role: 'assistant',
 41 |     content,  
 42 |     createdAt: new Date().toISOString()
 43 |   };
 44 | }
 45 | 
 46 | function inspectSSE(data: string) {
 47 |   try {
 48 |     // Handle special cases
 49 |     if (data.includes('[DONE]')) return true;
 50 |     if (!data.startsWith('data: ')) return false;
 51 |     
 52 |     // Extract JSON part, being more lenient with the ending
 53 |     const jsonStart = data.indexOf('{');
 54 |     const jsonEnd = data.lastIndexOf('}');
 55 |     
 56 |     if (jsonStart === -1 || jsonEnd === -1 || jsonEnd <= jsonStart) {
 57 |       console.error('Invalid JSON boundaries in SSE data');
 58 |       return false;
 59 |     }
 60 |     
 61 |     const jsonStr = data.slice(jsonStart, jsonEnd + 1);
 62 |     const parsed = JSON.parse(jsonStr);
 63 |     
 64 |     if (!validateChunkData(parsed)) {
 65 |       console.error('Invalid chunk structure:', parsed);
 66 |       return false;
 67 |     }
 68 |     
 69 |     return true;
 70 |   } catch (e: unknown) {
 71 |     console.error('SSE parse error:', {
 72 |       error: e instanceof Error ? e.message : String(e),
 73 |       data: data
 74 |     });
 75 |     return false;
 76 |   }
 77 | }
 78 | 
 79 | // Helper to safely encode content for SSE
 80 | function encodeContent(content: string): string {
 81 |   return content
 82 |     .replace(/\\/g, '\\\\')   // Escape backslashes first
 83 |     .replace(/\n/g, '\\n')    // Then escape newlines
 84 |     .replace(/\r/g, '\\r')    // Then carriage returns
 85 |     .replace(/\t/g, '\\t')    // Then tabs
 86 |     .replace(/"/g, '\\"');    // Then quotes
 87 | }
 88 | 
 89 | export const customModel = (apiIdentifier: string) => {
 90 |   return {
 91 |     id: apiIdentifier,
 92 |     provider: 'anthropic' as const,
 93 |     async invoke({ messages, options }: { messages: Message[]; options?: { system?: string } }) {
 94 |       console.log('=== Starting new chat invocation ===');
 95 |       console.log('Input messages:', messages);
 96 |       
 97 |       const formattedMessages = messages.map((msg) => ({
 98 |         role: msg.role === 'user' ? ('user' as const) : ('assistant' as const),
 99 |         content: msg.content,
100 |       }));
101 | 
102 |       console.log('Formatted messages for Anthropic:', formattedMessages);
103 |       
104 |       let response;
105 |       try {
106 |         response = await anthropic.messages.create({
107 |           model: apiIdentifier,
108 |           messages: formattedMessages,
109 |           system: options?.system,
110 |           max_tokens: 4096,
111 |           stream: true,
112 |         });
113 |         console.log('Successfully created Anthropic stream');
114 |       } catch (error) {
115 |         console.error('Error during API call to Anthropic:', error);
116 |         throw new Error('Failed to call Anthropic API');
117 |       }
118 | 
119 |       const encoder = new TextEncoder();
120 |       let streamClosed = false;
121 | 
122 |       const stream = new ReadableStream({
123 |         async start(controller) {
124 |           try {
125 |             let fullContent = '';
126 |             const messageId = crypto.randomUUID();
127 |             console.log('Generated message ID:', messageId);
128 | 
129 |             for await (const chunk of response) {
130 |               if (streamClosed) break;
131 | 
132 |               if (chunk.type === 'content_block_delta' && chunk.delta?.text) {
133 |                 try {
134 |                   fullContent += chunk.delta.text;
135 |                   const chunkData = createChunk(messageId, fullContent);
136 |                   const payload = JSON.stringify(chunkData);
137 |                   controller.enqueue(encoder.encode(`data: ${payload}\n\n`));
138 |                 } catch (error) {
139 |                   console.error('Chunk processing error:', error);
140 |                   continue;
141 |                 }
142 |               } else if (chunk.type === 'message_stop') {
143 |                 controller.enqueue(encoder.encode('data: [DONE]\n\n'));
144 |                 controller.close();
145 |                 break;
146 |               }
147 |             }
148 |           } catch (error) {
149 |             console.error('Stream error:', error);
150 |             controller.error(error);
151 |           }
152 |         },
153 |         cancel() {
154 |           streamClosed = true;
155 |         },
156 |       });
157 | 
158 |       return stream;
159 |     },
160 |   };
161 | };
162 | 


--------------------------------------------------------------------------------
/lib/ai/models.ts:
--------------------------------------------------------------------------------
 1 | import fs from 'fs';
 2 | 
 3 | export const encodeFileToBase64 = (file: File): Promise<string> => {
 4 |   return new Promise<string>((resolve, reject) => {
 5 |     const reader = new FileReader();
 6 |     reader.onload = () => {
 7 |       const base64String = reader.result?.toString().split(',')[1] || '';
 8 |       resolve(base64String);
 9 |     };
10 |     reader.onerror = reject;
11 |     reader.readAsDataURL(file);
12 |   });
13 | };
14 | 
15 | export const sendPdfToClaude = async (file: File, prompt: string) => {
16 |   const base64File = await encodeFileToBase64(file);
17 |   const response = await fetch('https://api.anthropic.com/v1/messages', {
18 |     method: 'POST',
19 |     headers: {
20 |       Authorization: `Bearer YOUR_CLAUDE_API_KEY`,
21 |       'Content-Type': 'application/json',
22 |       'anthropic-version': '2023-06-01',
23 |     },
24 |     body: JSON.stringify({
25 |       model: 'claude-3-5-sonnet-20241022',
26 |       max_tokens: 1024,
27 |       messages: [
28 |         {
29 |           role: 'user',
30 |           content: [
31 |             {
32 |               type: 'document',
33 |               source: {
34 |                 type: 'base64',
35 |                 media_type: 'application/pdf',
36 |                 data: base64File,
37 |               },
38 |             },
39 |             {
40 |               type: 'text',
41 |               text: prompt,
42 |             },
43 |           ],
44 |         },
45 |       ],
46 |     }),
47 |   });
48 | 
49 |   if (!response.ok) {
50 |     throw new Error(`Claude API error: ${response.statusText}`);
51 |   }
52 |   return response.json();
53 | };
54 | 


--------------------------------------------------------------------------------
/lib/ai/prompts.ts:
--------------------------------------------------------------------------------
 1 | export const medicalPrompt = `You are a medical education companion. Answer all queries in a concise, professional tone.
 2 | 
 3 | Start each response with a direct and brief answer to the user's question in the first sentence. Follow this with a short paragraph that provides context, explanation, or additional details relevant to the query.
 4 | 
 5 | Keep your responses clear, professional, and concise.`; // Removed document creation mentions
 6 | 
 7 | export const blocksInstructions = `
 8 | When the user asks you to create or update a document, or if the content is substantial (>10 lines) and suitable for saving/reuse (emails, code, essays, etc.), then follow these guidelines:
 9 | 
10 | *   Use the \`createDocument\` tool for creating new documents.
11 | *   Use the \`updateDocument\` tool for modifying existing documents.
12 | *   Default to full document rewrites for major changes.
13 | *   Use targeted updates only for specific, isolated changes.
14 | *   Follow user instructions for which parts to modify.
15 | *   Do not update a document immediately after creating it; wait for user feedback or a request to update.
16 | 
17 | **Do not mention creating a document unless you are actively using the \`createDocument\` tool.**`; // Focused on tool usage
18 | 
19 | export const systemPrompt = `${medicalPrompt}\n\n${blocksInstructions}`; // Separate instructions
20 | 


--------------------------------------------------------------------------------
/lib/db/migrate.ts:
--------------------------------------------------------------------------------
 1 | import { config } from 'dotenv';
 2 | import { drizzle } from 'drizzle-orm/postgres-js';
 3 | import { migrate } from 'drizzle-orm/postgres-js/migrator';
 4 | import postgres from 'postgres';
 5 | 
 6 | config({
 7 |   path: '.env.local',
 8 | });
 9 | 
10 | const runMigrate = async () => {
11 |   if (!process.env.POSTGRES_URL) {
12 |     throw new Error('POSTGRES_URL is not defined');
13 |   }
14 | 
15 |   const connection = postgres(process.env.POSTGRES_URL, { max: 1 });
16 |   const db = drizzle(connection);
17 | 
18 |   console.log('⏳ Running migrations...');
19 | 
20 |   const start = Date.now();
21 |   await migrate(db, { migrationsFolder: './lib/db/migrations' });
22 |   const end = Date.now();
23 | 
24 |   console.log('✅ Migrations completed in', end - start, 'ms');
25 |   process.exit(0);
26 | };
27 | 
28 | runMigrate().catch((err) => {
29 |   console.error('❌ Migration failed');
30 |   console.error(err);
31 |   process.exit(1);
32 | });
33 | 


--------------------------------------------------------------------------------
/lib/db/queries.ts:
--------------------------------------------------------------------------------
  1 | import 'server-only';
  2 | 
  3 | import { genSaltSync, hashSync } from 'bcrypt-ts';
  4 | import { and, asc, desc, eq, gt } from 'drizzle-orm';
  5 | import { drizzle } from 'drizzle-orm/postgres-js';
  6 | import postgres from 'postgres';
  7 | 
  8 | import {
  9 |   user,
 10 |   chat,
 11 |   type User,
 12 |   document,
 13 |   type Suggestion,
 14 |   suggestion,
 15 |   type Message,
 16 |   message,
 17 |   vote,
 18 | } from './schema';
 19 | 
 20 | // Optionally, if not using email/pass login, you can
 21 | // use the Drizzle adapter for Auth.js / NextAuth
 22 | // https://authjs.dev/reference/adapter/drizzle
 23 | 
 24 | // biome-ignore lint: Forbidden non-null assertion.
 25 | const client = postgres(process.env.POSTGRES_URL!);
 26 | const db = drizzle(client);
 27 | 
 28 | export async function getUser(email: string): Promise<Array<User>> {
 29 |   try {
 30 |     return await db.select().from(user).where(eq(user.email, email));
 31 |   } catch (error) {
 32 |     console.error('Failed to get user from database');
 33 |     throw error;
 34 |   }
 35 | }
 36 | 
 37 | export async function createUser(email: string, password: string) {
 38 |   const salt = genSaltSync(10);
 39 |   const hash = hashSync(password, salt);
 40 | 
 41 |   try {
 42 |     return await db.insert(user).values({ email, password: hash });
 43 |   } catch (error) {
 44 |     console.error('Failed to create user in database');
 45 |     throw error;
 46 |   }
 47 | }
 48 | 
 49 | export async function saveChat({
 50 |   id,
 51 |   userId,
 52 |   title,
 53 | }: {
 54 |   id: string;
 55 |   userId: string;
 56 |   title: string;
 57 | }) {
 58 |   try {
 59 |     return await db.insert(chat).values({
 60 |       id,
 61 |       createdAt: new Date(),
 62 |       userId,
 63 |       title,
 64 |     });
 65 |   } catch (error) {
 66 |     console.error('Failed to save chat in database');
 67 |     throw error;
 68 |   }
 69 | }
 70 | 
 71 | export async function deleteChatById({ id }: { id: string }) {
 72 |   try {
 73 |     await db.delete(vote).where(eq(vote.chatId, id));
 74 |     await db.delete(message).where(eq(message.chatId, id));
 75 | 
 76 |     return await db.delete(chat).where(eq(chat.id, id));
 77 |   } catch (error) {
 78 |     console.error('Failed to delete chat by id from database');
 79 |     throw error;
 80 |   }
 81 | }
 82 | 
 83 | export async function getChatsByUserId({ id }: { id: string }) {
 84 |   try {
 85 |     return await db
 86 |       .select()
 87 |       .from(chat)
 88 |       .where(eq(chat.userId, id))
 89 |       .orderBy(desc(chat.createdAt));
 90 |   } catch (error) {
 91 |     console.error('Failed to get chats by user from database');
 92 |     throw error;
 93 |   }
 94 | }
 95 | 
 96 | export async function getChatById({ id }: { id: string }) {
 97 |   try {
 98 |     const [selectedChat] = await db.select().from(chat).where(eq(chat.id, id));
 99 |     return selectedChat;
100 |   } catch (error) {
101 |     console.error('Failed to get chat by id from database');
102 |     throw error;
103 |   }
104 | }
105 | 
106 | export async function saveMessages({ messages }: { messages: Array<Message> }) {
107 |   try {
108 |     return await db.insert(message).values(messages);
109 |   } catch (error) {
110 |     console.error('Failed to save messages in database', error);
111 |     throw error;
112 |   }
113 | }
114 | 
115 | export async function getMessagesByChatId({ id }: { id: string }) {
116 |   try {
117 |     return await db
118 |       .select()
119 |       .from(message)
120 |       .where(eq(message.chatId, id))
121 |       .orderBy(asc(message.createdAt));
122 |   } catch (error) {
123 |     console.error('Failed to get messages by chat id from database', error);
124 |     throw error;
125 |   }
126 | }
127 | 
128 | export async function voteMessage({
129 |   chatId,
130 |   messageId,
131 |   type,
132 | }: {
133 |   chatId: string;
134 |   messageId: string;
135 |   type: 'up' | 'down';
136 | }) {
137 |   try {
138 |     const [existingVote] = await db
139 |       .select()
140 |       .from(vote)
141 |       .where(and(eq(vote.messageId, messageId)));
142 | 
143 |     if (existingVote) {
144 |       return await db
145 |         .update(vote)
146 |         .set({ isUpvoted: type === 'up' })
147 |         .where(and(eq(vote.messageId, messageId), eq(vote.chatId, chatId)));
148 |     }
149 |     return await db.insert(vote).values({
150 |       chatId,
151 |       messageId,
152 |       isUpvoted: type === 'up',
153 |     });
154 |   } catch (error) {
155 |     console.error('Failed to upvote message in database', error);
156 |     throw error;
157 |   }
158 | }
159 | 
160 | export async function getVotesByChatId({ id }: { id: string }) {
161 |   try {
162 |     return await db.select().from(vote).where(eq(vote.chatId, id));
163 |   } catch (error) {
164 |     console.error('Failed to get votes by chat id from database', error);
165 |     throw error;
166 |   }
167 | }
168 | 
169 | export async function saveDocument({
170 |   id,
171 |   title,
172 |   content,
173 |   userId,
174 | }: {
175 |   id: string;
176 |   title: string;
177 |   content: string;
178 |   userId: string;
179 | }) {
180 |   try {
181 |     return await db.insert(document).values({
182 |       id,
183 |       title,
184 |       content,
185 |       userId,
186 |       createdAt: new Date(),
187 |     });
188 |   } catch (error) {
189 |     console.error('Failed to save document in database');
190 |     throw error;
191 |   }
192 | }
193 | 
194 | export async function getDocumentsById({ id }: { id: string }) {
195 |   try {
196 |     const documents = await db
197 |       .select()
198 |       .from(document)
199 |       .where(eq(document.id, id))
200 |       .orderBy(asc(document.createdAt));
201 | 
202 |     return documents;
203 |   } catch (error) {
204 |     console.error('Failed to get document by id from database');
205 |     throw error;
206 |   }
207 | }
208 | 
209 | export async function getDocumentById({ id }: { id: string }) {
210 |   try {
211 |     const [selectedDocument] = await db
212 |       .select()
213 |       .from(document)
214 |       .where(eq(document.id, id))
215 |       .orderBy(desc(document.createdAt));
216 | 
217 |     return selectedDocument;
218 |   } catch (error) {
219 |     console.error('Failed to get document by id from database');
220 |     throw error;
221 |   }
222 | }
223 | 
224 | export async function deleteDocumentsByIdAfterTimestamp({
225 |   id,
226 |   timestamp,
227 | }: {
228 |   id: string;
229 |   timestamp: Date;
230 | }) {
231 |   try {
232 |     await db
233 |       .delete(suggestion)
234 |       .where(
235 |         and(
236 |           eq(suggestion.documentId, id),
237 |           gt(suggestion.documentCreatedAt, timestamp),
238 |         ),
239 |       );
240 | 
241 |     return await db
242 |       .delete(document)
243 |       .where(and(eq(document.id, id), gt(document.createdAt, timestamp)));
244 |   } catch (error) {
245 |     console.error(
246 |       'Failed to delete documents by id after timestamp from database',
247 |     );
248 |     throw error;
249 |   }
250 | }
251 | 
252 | export async function saveSuggestions({
253 |   suggestions,
254 | }: {
255 |   suggestions: Array<Suggestion>;
256 | }) {
257 |   try {
258 |     return await db.insert(suggestion).values(suggestions);
259 |   } catch (error) {
260 |     console.error('Failed to save suggestions in database');
261 |     throw error;
262 |   }
263 | }
264 | 
265 | export async function getSuggestionsByDocumentId({
266 |   documentId,
267 | }: {
268 |   documentId: string;
269 | }) {
270 |   try {
271 |     return await db
272 |       .select()
273 |       .from(suggestion)
274 |       .where(and(eq(suggestion.documentId, documentId)));
275 |   } catch (error) {
276 |     console.error(
277 |       'Failed to get suggestions by document version from database',
278 |     );
279 |     throw error;
280 |   }
281 | }
282 | 


--------------------------------------------------------------------------------
/lib/db/schema.ts:
--------------------------------------------------------------------------------
  1 | import type { InferSelectModel } from 'drizzle-orm';
  2 | import {
  3 |   pgTable,
  4 |   varchar,
  5 |   timestamp,
  6 |   json,
  7 |   uuid,
  8 |   text,
  9 |   primaryKey,
 10 |   foreignKey,
 11 |   boolean,
 12 | } from 'drizzle-orm/pg-core';
 13 | 
 14 | export const user = pgTable('User', {
 15 |   id: uuid('id').primaryKey().notNull().defaultRandom(),
 16 |   email: varchar('email', { length: 64 }).notNull(),
 17 |   password: varchar('password', { length: 64 }),
 18 | });
 19 | 
 20 | export type User = InferSelectModel<typeof user>;
 21 | 
 22 | export const chat = pgTable('Chat', {
 23 |   id: uuid('id').primaryKey().notNull().defaultRandom(),
 24 |   createdAt: timestamp('createdAt').notNull(),
 25 |   title: text('title').notNull(),
 26 |   userId: uuid('userId')
 27 |     .notNull()
 28 |     .references(() => user.id),
 29 | });
 30 | 
 31 | export type Chat = InferSelectModel<typeof chat>;
 32 | 
 33 | export const message = pgTable('Message', {
 34 |   id: uuid('id').primaryKey().notNull().defaultRandom(),
 35 |   chatId: uuid('chatId')
 36 |     .notNull()
 37 |     .references(() => chat.id),
 38 |   role: varchar('role').notNull(),
 39 |   content: json('content').notNull(),
 40 |   createdAt: timestamp('createdAt').notNull(),
 41 | });
 42 | 
 43 | export type Message = InferSelectModel<typeof message>;
 44 | 
 45 | export const vote = pgTable(
 46 |   'Vote',
 47 |   {
 48 |     chatId: uuid('chatId')
 49 |       .notNull()
 50 |       .references(() => chat.id),
 51 |     messageId: uuid('messageId')
 52 |       .notNull()
 53 |       .references(() => message.id),
 54 |     isUpvoted: boolean('isUpvoted').notNull(),
 55 |   },
 56 |   (table) => {
 57 |     return {
 58 |       pk: primaryKey({ columns: [table.chatId, table.messageId] }),
 59 |     };
 60 |   },
 61 | );
 62 | 
 63 | export type Vote = InferSelectModel<typeof vote>;
 64 | 
 65 | export const document = pgTable(
 66 |   'Document',
 67 |   {
 68 |     id: uuid('id').notNull().defaultRandom(),
 69 |     createdAt: timestamp('createdAt').notNull(),
 70 |     title: text('title').notNull(),
 71 |     content: text('content'),
 72 |     userId: uuid('userId')
 73 |       .notNull()
 74 |       .references(() => user.id),
 75 |   },
 76 |   (table) => {
 77 |     return {
 78 |       pk: primaryKey({ columns: [table.id, table.createdAt] }),
 79 |     };
 80 |   },
 81 | );
 82 | 
 83 | export type Document = InferSelectModel<typeof document>;
 84 | 
 85 | export const suggestion = pgTable(
 86 |   'Suggestion',
 87 |   {
 88 |     id: uuid('id').notNull().defaultRandom(),
 89 |     documentId: uuid('documentId').notNull(),
 90 |     documentCreatedAt: timestamp('documentCreatedAt').notNull(),
 91 |     originalText: text('originalText').notNull(),
 92 |     suggestedText: text('suggestedText').notNull(),
 93 |     description: text('description'),
 94 |     isResolved: boolean('isResolved').notNull().default(false),
 95 |     userId: uuid('userId')
 96 |       .notNull()
 97 |       .references(() => user.id),
 98 |     createdAt: timestamp('createdAt').notNull(),
 99 |   },
100 |   (table) => ({
101 |     pk: primaryKey({ columns: [table.id] }),
102 |     documentRef: foreignKey({
103 |       columns: [table.documentId, table.documentCreatedAt],
104 |       foreignColumns: [document.id, document.createdAt],
105 |     }),
106 |   }),
107 | );
108 | 
109 | export type Suggestion = InferSelectModel<typeof suggestion>;
110 | 


--------------------------------------------------------------------------------
/lib/editor/config.ts:
--------------------------------------------------------------------------------
 1 | import { textblockTypeInputRule } from 'prosemirror-inputrules';
 2 | import { Schema } from 'prosemirror-model';
 3 | import { schema } from 'prosemirror-schema-basic';
 4 | import { addListNodes } from 'prosemirror-schema-list';
 5 | import type { Transaction } from 'prosemirror-state';
 6 | import type { EditorView } from 'prosemirror-view';
 7 | import type { MutableRefObject } from 'react';
 8 | 
 9 | import { buildContentFromDocument } from './functions';
10 | 
11 | export const documentSchema = new Schema({
12 |   nodes: addListNodes(schema.spec.nodes, 'paragraph block*', 'block'),
13 |   marks: schema.spec.marks,
14 | });
15 | 
16 | export function headingRule(level: number) {
17 |   return textblockTypeInputRule(
18 |     new RegExp(`^(#{1,${level}})\\s




    
    

    
    
    
    

    
    
    
    



    



    

    

    

        ),
19 |     documentSchema.nodes.heading,
20 |     () => ({ level }),
21 |   );
22 | }
23 | 
24 | export const handleTransaction = ({
25 |   transaction,
26 |   editorRef,
27 |   saveContent,
28 | }: {
29 |   transaction: Transaction;
30 |   editorRef: MutableRefObject<EditorView | null>;
31 |   saveContent: (updatedContent: string, debounce: boolean) => void;
32 | }) => {
33 |   if (!editorRef || !editorRef.current) return;
34 | 
35 |   const newState = editorRef.current.state.apply(transaction);
36 |   editorRef.current.updateState(newState);
37 | 
38 |   if (transaction.docChanged && !transaction.getMeta('no-save')) {
39 |     const updatedContent = buildContentFromDocument(newState.doc);
40 | 
41 |     if (transaction.getMeta('no-debounce')) {
42 |       saveContent(updatedContent, false);
43 |     } else {
44 |       saveContent(updatedContent, true);
45 |     }
46 |   }
47 | };
48 | 


--------------------------------------------------------------------------------
/lib/utils.ts:
--------------------------------------------------------------------------------
  1 | import type {
  2 |   CoreAssistantMessage,
  3 |   CoreMessage,
  4 |   CoreToolMessage,
  5 |   Message,
  6 |   ToolInvocation,
  7 | } from 'ai';
  8 | import { type ClassValue, clsx } from 'clsx';
  9 | import { twMerge } from 'tailwind-merge';
 10 | 
 11 | import type { Message as DBMessage, Document } from '@/lib/db/schema';
 12 | 
 13 | export function cn(...inputs: ClassValue[]) {
 14 |   return twMerge(clsx(inputs));
 15 | }
 16 | 
 17 | interface ApplicationError extends Error {
 18 |   info: string;
 19 |   status: number;
 20 | }
 21 | 
 22 | export const fetcher = async (url: string) => {
 23 |   const res = await fetch(url);
 24 | 
 25 |   if (!res.ok) {
 26 |     const error = new Error(
 27 |       'An error occurred while fetching the data.',
 28 |     ) as ApplicationError;
 29 | 
 30 |     error.info = await res.json();
 31 |     error.status = res.status;
 32 | 
 33 |     throw error;
 34 |   }
 35 | 
 36 |   return res.json();
 37 | };
 38 | 
 39 | export function getLocalStorage(key: string) {
 40 |   if (typeof window !== 'undefined') {
 41 |     return JSON.parse(localStorage.getItem(key) || '[]');
 42 |   }
 43 |   return [];
 44 | }
 45 | 
 46 | export function generateUUID(): string {
 47 |   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
 48 |     const r = (Math.random() * 16) | 0;
 49 |     const v = c === 'x' ? r : (r & 0x3) | 0x8;
 50 |     return v.toString(16);
 51 |   });
 52 | }
 53 | 
 54 | export async function fileToBase64(file: File): Promise<string> {
 55 |   return new Promise((resolve, reject) => {
 56 |     const reader = new FileReader();
 57 |     reader.readAsDataURL(file);
 58 |     reader.onload = () => {
 59 |       const base64String = (reader.result as string)
 60 |         .replace('data:', '')
 61 |         .replace(/^.+,/, '');
 62 |       resolve(base64String);
 63 |     };
 64 |     reader.onerror = (error) => reject(error);
 65 |   });
 66 | }
 67 | 
 68 | function addToolMessageToChat({
 69 |   toolMessage,
 70 |   messages,
 71 | }: {
 72 |   toolMessage: CoreToolMessage;
 73 |   messages: Array<Message>;
 74 | }): Array<Message> {
 75 |   return messages.map((message) => {
 76 |     if (message.toolInvocations) {
 77 |       return {
 78 |         ...message,
 79 |         toolInvocations: message.toolInvocations.map((toolInvocation) => {
 80 |           const toolResult = toolMessage.content.find(
 81 |             (tool) => tool.toolCallId === toolInvocation.toolCallId,
 82 |           );
 83 | 
 84 |           if (toolResult) {
 85 |             return {
 86 |               ...toolInvocation,
 87 |               state: 'result',
 88 |               result: toolResult.result,
 89 |             };
 90 |           }
 91 | 
 92 |           return toolInvocation;
 93 |         }),
 94 |       };
 95 |     }
 96 | 
 97 |     return message;
 98 |   });
 99 | }
100 | 
101 | export function convertToUIMessages(
102 |   messages: Array<DBMessage>,
103 | ): Array<Message> {
104 |   return messages.reduce((chatMessages: Array<Message>, message) => {
105 |     if (message.role === 'tool') {
106 |       return addToolMessageToChat({
107 |         toolMessage: message as CoreToolMessage,
108 |         messages: chatMessages,
109 |       });
110 |     }
111 | 
112 |     let textContent = '';
113 |     const toolInvocations: Array<ToolInvocation> = [];
114 | 
115 |     if (typeof message.content === 'string') {
116 |       textContent = message.content;
117 |     } else if (Array.isArray(message.content)) {
118 |       for (const content of message.content) {
119 |         if (content.type === 'text') {
120 |           textContent += content.text;
121 |         } else if (content.type === 'tool-call') {
122 |           toolInvocations.push({
123 |             state: 'call',
124 |             toolCallId: content.toolCallId,
125 |             toolName: content.toolName,
126 |             args: content.args,
127 |           });
128 |         }
129 |       }
130 |     }
131 | 
132 |     chatMessages.push({
133 |       id: message.id,
134 |       role: message.role as Message['role'],
135 |       content: textContent,
136 |       toolInvocations,
137 |     });
138 | 
139 |     return chatMessages;
140 |   }, []);
141 | }
142 | 
143 | export function sanitizeResponseMessages(
144 |   messages: Array<CoreToolMessage | CoreAssistantMessage>,
145 | ): Array<CoreToolMessage | CoreAssistantMessage> {
146 |   const toolResultIds: Array<string> = [];
147 | 
148 |   for (const message of messages) {
149 |     if (message.role === 'tool') {
150 |       for (const content of message.content) {
151 |         if (content.type === 'tool-result') {
152 |           toolResultIds.push(content.toolCallId);
153 |         }
154 |       }
155 |     }
156 |   }
157 | 
158 |   const messagesBySanitizedContent = messages.map((message) => {
159 |     if (message.role !== 'assistant') return message;
160 | 
161 |     if (typeof message.content === 'string') return message;
162 | 
163 |     const sanitizedContent = message.content.filter((content) =>
164 |       content.type === 'tool-call'
165 |         ? toolResultIds.includes(content.toolCallId)
166 |         : content.type === 'text'
167 |           ? content.text.length > 0
168 |           : true,
169 |     );
170 | 
171 |     return {
172 |       ...message,
173 |       content: sanitizedContent,
174 |     };
175 |   });
176 | 
177 |   return messagesBySanitizedContent.filter(
178 |     (message) => message.content.length > 0,
179 |   );
180 | }
181 | 
182 | export function sanitizeUIMessages(messages: Array<Message>): Array<Message> {
183 |   const messagesBySanitizedToolInvocations = messages.map((message) => {
184 |     if (message.role !== 'assistant') return message;
185 | 
186 |     if (!message.toolInvocations) return message;
187 | 
188 |     const toolResultIds: Array<string> = [];
189 | 
190 |     for (const toolInvocation of message.toolInvocations) {
191 |       if (toolInvocation.state === 'result') {
192 |         toolResultIds.push(toolInvocation.toolCallId);
193 |       }
194 |     }
195 | 
196 |     const sanitizedToolInvocations = message.toolInvocations.filter(
197 |       (toolInvocation) =>
198 |         toolInvocation.state === 'result' ||
199 |         toolResultIds.includes(toolInvocation.toolCallId),
200 |     );
201 | 
202 |     return {
203 |       ...message,
204 |       toolInvocations: sanitizedToolInvocations,
205 |     };
206 |   });
207 | 
208 |   return messagesBySanitizedToolInvocations.filter(
209 |     (message) =>
210 |       message.content.length > 0 ||
211 |       (message.toolInvocations && message.toolInvocations.length > 0),
212 |   );
213 | }
214 | 
215 | export function getMostRecentUserMessage(messages: Array<CoreMessage>) {
216 |   const userMessages = messages.filter((message) => message.role === 'user');
217 |   return userMessages.at(-1);
218 | }
219 | 
220 | export function getDocumentTimestampByIndex(
221 |   documents: Array<Document>,
222 |   index: number,
223 | ) {
224 |   if (!documents) return new Date();
225 |   if (index > documents.length) return new Date();
226 | 
227 |   return documents[index].createdAt;
228 | }
229 | 
230 | export function getMessageIdFromAnnotations(message: Message) {
231 |   if (!message.annotations) return message.id;
232 | 
233 |   const [annotation] = message.annotations;
234 |   if (!annotation) return message.id;
235 | 
236 |   // @ts-expect-error messageIdFromServer is not defined in MessageAnnotation
237 |   return annotation.messageIdFromServer;
238 | }
239 | 


--------------------------------------------------------------------------------
/middleware.ts:
--------------------------------------------------------------------------------
 1 | import NextAuth from 'next-auth';
 2 | 
 3 | import { authConfig } from '@/app/(auth)/auth.config';
 4 | 
 5 | export default NextAuth(authConfig).auth;
 6 | 
 7 | export const config = {
 8 |   matcher: ['/', '/:id', '/api/:path*', '/login', '/register'],
 9 | };
10 | 


--------------------------------------------------------------------------------
/next-env.d.ts:
--------------------------------------------------------------------------------
1 | /// <reference types="next" />
2 | /// <reference types="next/image-types/global" />
3 | 
4 | // NOTE: This file should not be edited
5 | // see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.
6 | 


--------------------------------------------------------------------------------
/next.config.ts:
--------------------------------------------------------------------------------
 1 | import type { NextConfig } from 'next';
 2 | 
 3 | const nextConfig: NextConfig = {
 4 |   /* config options here */
 5 |   experimental: {
 6 |     ppr: true,
 7 |   },
 8 |   images: {
 9 |     remotePatterns: [
10 |       {
11 |         hostname: 'avatar.vercel.sh',
12 |       },
13 |     ],
14 |   },
15 | };
16 | 
17 | export default nextConfig;
18 | 


--------------------------------------------------------------------------------
/tailwind.config.ts:
--------------------------------------------------------------------------------
 1 | import type { Config } from 'tailwindcss';
 2 | 
 3 | const config: Config = {
 4 |   darkMode: ['class'],
 5 |   content: [
 6 |     './pages/**/*.{js,ts,jsx,tsx,mdx}',
 7 |     './components/**/*.{js,ts,jsx,tsx,mdx}',
 8 |     './app/**/*.{js,ts,jsx,tsx,mdx}',
 9 |   ],
10 |   theme: {
11 |     fontFamily: {
12 |       sans: ['geist'],
13 |       mono: ['geist-mono'],
14 |     },
15 |     extend: {
16 |       borderRadius: {
17 |         lg: 'var(--radius)',
18 |         md: 'calc(var(--radius) - 2px)',
19 |         sm: 'calc(var(--radius) - 4px)',
20 |       },
21 |       colors: {
22 |         background: 'hsl(var(--background))',
23 |         foreground: 'hsl(var(--foreground))',
24 |         card: {
25 |           DEFAULT: 'hsl(var(--card))',
26 |           foreground: 'hsl(var(--card-foreground))',
27 |         },
28 |         popover: {
29 |           DEFAULT: 'hsl(var(--popover))',
30 |           foreground: 'hsl(var(--popover-foreground))',
31 |         },
32 |         primary: {
33 |           DEFAULT: 'hsl(var(--primary))',
34 |           foreground: 'hsl(var(--primary-foreground))',
35 |         },
36 |         secondary: {
37 |           DEFAULT: 'hsl(var(--secondary))',
38 |           foreground: 'hsl(var(--secondary-foreground))',
39 |         },
40 |         muted: {
41 |           DEFAULT: 'hsl(var(--muted))',
42 |           foreground: 'hsl(var(--muted-foreground))',
43 |         },
44 |         accent: {
45 |           DEFAULT: 'hsl(var(--accent))',
46 |           foreground: 'hsl(var(--accent-foreground))',
47 |         },
48 |         destructive: {
49 |           DEFAULT: 'hsl(var(--destructive))',
50 |           foreground: 'hsl(var(--destructive-foreground))',
51 |         },
52 |         border: 'hsl(var(--border))',
53 |         input: 'hsl(var(--input))',
54 |         ring: 'hsl(var(--ring))',
55 |         chart: {
56 |           '1': 'hsl(var(--chart-1))',
57 |           '2': 'hsl(var(--chart-2))',
58 |           '3': 'hsl(var(--chart-3))',
59 |           '4': 'hsl(var(--chart-4))',
60 |           '5': 'hsl(var(--chart-5))',
61 |         },
62 |         sidebar: {
63 |           DEFAULT: 'hsl(var(--sidebar-background))',
64 |           foreground: 'hsl(var(--sidebar-foreground))',
65 |           primary: 'hsl(var(--sidebar-primary))',
66 |           'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
67 |           accent: 'hsl(var(--sidebar-accent))',
68 |           'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
69 |           border: 'hsl(var(--sidebar-border))',
70 |           ring: 'hsl(var(--sidebar-ring))',
71 |         },
72 |       },
73 |     },
74 |   },
75 |   plugins: [require('tailwindcss-animate'), require('@tailwindcss/typography')],
76 | };
77 | export default config;
78 | 


--------------------------------------------------------------------------------
/types/chat.ts:
--------------------------------------------------------------------------------
 1 | export interface Attachment {
 2 |   name: string;
 3 |   type: string;
 4 |   base64: string;
 5 | }
 6 | 
 7 | export interface Message {
 8 |   role: 'user' | 'assistant';
 9 |   content: string;
10 |   experimental_attachments?: Attachment[];
11 | }
12 | 
